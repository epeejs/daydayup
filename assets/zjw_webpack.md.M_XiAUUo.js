import{_ as i,c as a,o as s,a4 as e}from"./chunks/framework.D5F7AbHZ.js";const g=JSON.parse('{"title":"webpack 总览","description":"","frontmatter":{},"headers":[],"relativePath":"zjw/webpack.md","filePath":"zjw/webpack.md"}'),l={name:"zjw/webpack.md"},t=e(`<h1 id="webpack-总览" tabindex="-1">webpack 总览 <a class="header-anchor" href="#webpack-总览" aria-label="Permalink to &quot;webpack 总览&quot;">​</a></h1><p>loader 用于转换某些类型的模块，插件则用于扩展 webpack 功能，通过注入钩子参与构建流程</p><h2 id="构建流程" tabindex="-1">构建流程 <a class="header-anchor" href="#构建流程" aria-label="Permalink to &quot;构建流程&quot;">​</a></h2><ol><li>初始化参数</li><li>通过参数初始化 Compiler 对象，加载所有配置的插件，执行 run 方法开始编译</li><li>根据 entry 递归找到所有依赖，并根据文件类型，使用配置 loader 处理文件</li><li>完成所有模块转换后，构建依赖图</li><li>根据依赖图组装成一个个包含多模块的 chunk，再把 chunk 加入输出列表（插件最后修改输出内容时机）</li><li>根据配置确定输出内容的路径与文件名，写入文件系统</li></ol><h2 id="打包速度优化-简言之-减少打包量、并行、缓存、预构建" tabindex="-1">打包速度优化（简言之：减少打包量、并行、缓存、预构建） <a class="header-anchor" href="#打包速度优化-简言之-减少打包量、并行、缓存、预构建" aria-label="Permalink to &quot;打包速度优化（简言之：减少打包量、并行、缓存、预构建）&quot;">​</a></h2><ul><li>缩小处理文件 <ul><li>resolve.alias：直接指定打包好的代码（仅开发）</li><li>优化 loader 配置：开启缓存、include 减少匹配文件</li><li>减少文件匹配路径：resolve 匹配规则</li><li>优化解析规则：module.noParse 指定不使用模块化解析文件</li><li>按需加载</li><li><a href="https://webpack.docschina.org/configuration/experiments/#experimentslazycompilation" target="_blank" rel="noreferrer">懒编译</a></li></ul></li><li>并行打包</li><li><a href="https://webpack.docschina.org/configuration/cache/" target="_blank" rel="noreferrer">构建缓存</a></li><li>模块联邦</li></ul><blockquote><p>webpack4 打包速度优化<a href="./webpack-pack-optimization">文档【旧】</a></p></blockquote><h2 id="webpack-hrm-原理" tabindex="-1">webpack HRM 原理 <a class="header-anchor" href="#webpack-hrm-原理" aria-label="Permalink to &quot;webpack HRM 原理&quot;">​</a></h2><p>webpack-dev-server 向网页注入用于连接开发服务的客户端代码，在代码变更时编译出新的补丁文件，发送到网页执行</p><p>当模块变更后，更新事件会向上传递，直到某层接受了当前变化的模块，就会调用 callback 去执行自定义逻辑。当上抛到最外层没有被接受，就会刷新整个网页</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./App&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;, window.document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="scope-hoisting-作用域提升" tabindex="-1">Scope Hoisting（作用域提升） <a class="header-anchor" href="#scope-hoisting-作用域提升" aria-label="Permalink to &quot;Scope Hoisting（作用域提升）&quot;">​</a></h2><p>合并 ES6 模块导入，且只被引用一次</p><p>好处：代码体积更小；内存开销减少，通过减少作用域创建函数</p><h2 id="compiler-和-compilation" tabindex="-1">Compiler 和 Compilation <a class="header-anchor" href="#compiler-和-compilation" aria-label="Permalink to &quot;Compiler 和 Compilation&quot;">​</a></h2><p>compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 compilation 只是代表了一次新的编译，由 compiler 每次构建创建</p><p>compilation 包含了当前的模块资源、编译生成资源、变化的文件等</p><h2 id="loader-用法" tabindex="-1">loader 用法 <a class="header-anchor" href="#loader-用法" aria-label="Permalink to &quot;loader 用法&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 用正则去匹配要用该 loader 转换的 CSS 文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">css</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;style-loader&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;css-loader?minimize&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>use 属性由 loader 名称组成的数组，loader 从后往前执行</li><li>每个 loader 可以通过 URL querystring 方式传入参数，也可以通过对象形式传入 <code>{ loader: &#39;css-loader&#39;, options: { minimize: true } }</code></li><li>内联方式使用 loader，<code>import &#39;!style-loader!css-loader?minimize!./styles.css&#39;</code></li></ul><h2 id="loader-执行循序" tabindex="-1">loader 执行循序 <a class="header-anchor" href="#loader-执行循序" aria-label="Permalink to &quot;loader 执行循序&quot;">​</a></h2>`,21),n=[t];function h(p,r,k,o,d,c){return s(),a("div",null,n)}const u=i(l,[["render",h]]);export{g as __pageData,u as default};
